foreach (letterPixels pxs in pxToCheck)
						{
							//Check Left
							if (CheckBlack(input_Image.GetPixel(x - 1, y)))
							{
								pxs.l.px = Color.FromArgb(255, 255, 255);
								pxs.l.origin = "r";
								pxToCheck.AddLast(pxs.l);
							}

							//Check Right
							if (CheckBlack(input_Image.GetPixel(x - 1, y)))
							{
								pxs.r.px = Color.FromArgb(255, 255, 255);
								pxs.r.origin = "l";
								pxToCheck.AddLast(pxs.r);
							}

							//Check Up
							if (CheckBlack(input_Image.GetPixel(x - 1, y)))
							{
								pxs.u.px = Color.FromArgb(255, 255, 255);
								pxs.u.origin = "d";
								pxToCheck.AddLast(pxs.d);
							}

							//Check Down
							if (CheckBlack(input_Image.GetPixel(x - 1, y)))
							{
								pxs.d.px = Color.FromArgb(255, 255, 255);
								pxs.d.origin = "u";
								pxToCheck.AddLast(pxs.u);
							}

						}



pxs.l.px = Color.FromArgb(0, 0, 0);
								pxs.l.origin = "r";


if (write.l.px != null)
							{
								if (write.l.px != empty)
								{
									newLetter.SetPixel(write.x - 1, write.y, black);
									write.l.px = empty;
									write.l.x = write.x - 1;
									write.l.y = write.y;
									nextPx.AddLast(write.l);
								}
							}

							//Check Right
							if (write.r.px != null)
							{
								if (write.r.px != empty)
								{
									newLetter.SetPixel(write.x + 1, write.y, black);
									write.r.px = empty;
									write.r.x = write.x + 1;
									write.r.y = write.y;
									nextPx.AddLast(write.r);
								}
							}

							//Check Up
							if (write.u.px != null)
							{
								if (write.u.px != empty)
								{
									newLetter.SetPixel(write.x, write.y + 1, black);
									write.u.px = empty;
									write.u.x = write.x;
									write.u.x = write.y + 1;
									nextPx.AddLast(write.u);
								}
							}

							//Check Down
							if (write.d.px != null)
							{
								if (write.d.px != empty)
								{
									newLetter.SetPixel(write.x, write.y - 1, black);
									write.d.px = empty;
									write.d.x = write.x;
									write.d.y = write.y - 1;
									nextPx.AddLast(write.d);
								}
							}



							//Color[] pixels = BackgroundEdit.GetAllPixels(input_image);

			for (int y = 0; y < input_image.Height; y++)
			{
				for (int x = 0; x < input_image.Width; x++, i++)
				{
					if (CheckBlack(pixels[x, y]))
					{
						//Check all 8 possible pixels arround it, then check those.
						//Build up a grid of the letter.



					}
				}
			}


			foreach (Color pixel in pixels)
			{
				//If the pixel is black
				if (CheckBlack(pixel))
				{

				}
			}

		}

		public static void CheckBlack(Color pixel)
		{
			if (pixel.GetBrightness < 0.1)
			{
				return true;
			}
			return false;
		}*/


CREATE TABLE [dbo].[User_Data] (
    [User_ID]       INT NOT NULL IDENTITY,
    [User_Name]     VARCHAR (64) NOT NULL,
    [User_Password] VARCHAR (64) NOT NULL,
    PRIMARY KEY CLUSTERED ([User_ID] ASC)
);

		/* private LinkedList<letterData> sortList(LinkedList<letterData> listToSort)
		{
			LinkedList<letterData> sortedLL = new LinkedList<letterData>();
			int length = listToSort.Count();
			letterData[] orderedLetters = new letterData[length];

			//Convert listToSort into an array that will be used for sorting.
			int counter = 0;

			foreach (letterData l in listToSort)
			{
				orderedLetters[counter] = l;
				counter++;
			}

			mergeSort(orderedLetters, 0, orderedLetters.Length - 1, orderedLetters.Length);

			foreach (letterData l in orderedLetters)
			{
				sortedLL.AddLast(l);
			}

			return sortedLL;
		}

		private void mergeSort(letterData[] arrayToSort, int left, int right, int len)
		{
			int mid;
			if (right > left)
			{
				mid = (right + left) / 2;
				mergeSort(arrayToSort, left, mid, len);
				mergeSort(arrayToSort, (mid + 1), right, len);
				mergeMethod(arrayToSort, left, mid++, right, len);
			}
		}

		private void mergeMethod(letterData[] lData, int left, int mid, int right, int len)
		{
			letterData[] temp = new letterData[len];
			int leftEnd, numberOfElements, tempPos;
			leftEnd = mid - 1;
			tempPos = left;
			numberOfElements = (right - Left + 1);

			while ((left <= leftEnd) && (mid <= right))
			{
				if (lData[left].Frequency <= lData[mid].Frequency)
				{
					temp[tempPos++] = lData[mid++];
				}
				else
				{
					temp[tempPos++] = lData[mid++];
				}
			}

			while (left <= leftEnd)
			{
				temp[tempPos++] = lData[left++];
			}

			while (mid <= right)
			{
				temp[tempPos++] = lData[right];
			}

			for (int i = 0; i < numberOfElements; i++)
			{
				lData[right] = temp[right];
				right--;
			}
		} */